<!DOCTYPE html>
<html class="h-full">

<head>
  <meta charset='utf-8' />
  <title>Get started with the Isochrone API</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <!-- Import Mapbox GL JS  -->
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.js'></script>
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.css' rel='stylesheet' />
  <!-- Import Assembly -->
  <link href='https://api.mapbox.com/mapbox-assembly/v0.23.2/assembly.min.css' rel='stylesheet'>
  <script src='https://api.mapbox.com/mapbox-assembly/v0.23.2/assembly.js'></script>
  <!-- Import jQuery -->
  <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>
  <!-- Import Turfjs for poligon simplification -->
  <script src='https://unpkg.com/@turf/turf/turf.min.js'></script>
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  <style>
    .w400{
      width: 420px;
    }
    .logo .ico{
      /*padding-left: 11px;
      padding-right: 11px;
      padding-top: 6px;
      padding-bottom: 7px;*/
      width: 60px;
    }

    #links{
      position: absolute;
      top: 0px;
      right: 20px;
    }

    #links img{
      border-radius: 9999px;
      margin-right: 20px;
    }

    .fs1facebookShareButton {
      border-radius: border-radius: 9999px;
      cursor: pointer;
      min-width: 24px;
      white-space: nowrap;
      display: inline-block;
    }

    .fs1shareButton {
      height: 25px;
      border-radius: 2px;
      border-width: 1px;
      border-style: solid;
      border-color: #9aabc6 #6f83ad #6176a3;
      background: url(https://static.parastorage.com/services/skins/2.1229.80/images/wysiwyg/core/themes/base/bg_fbshare.png) 0 0 repeat-x;
    }

    .fs1icon {
      width: 21px;
      height: 21px;
      background: url(https://static.parastorage.com/services/skins/2.1229.80/images/wysiwyg/core/themes/base/facebooklogo.png) 5px 3px no-repeat;
      border-right: 1px solid #425e85;
      position: absolute;
    }

    .fs1label {
      line-height: 21px;
      margin-left: 22px;
      padding: 3px 6px;
      color: #fff;
      font-size: 12px;
      text-shadow: 1px 1px 1px #304871;
      border-left: 1px solid #6176a3;
      vertical-align: top;
    }

    .scrolled {
      overflow-x: scroll;
      overflow-y: overlay;
      -webkit-overflow-scrolling: touch;
    }

  </style>

</head>

<body class="h-full">
  <!-- Create a container for the map -->

<div class='flex-parent h-full'>
  <div class='flex-child flex-child--no-shrink px24 pb24 w400 h-full' style="padding-top: 320px">

    <div class="logo fixed flex-parent flex-parent--center-cross pb18 border-b border--gray-light w360" style="top:10px;">
      <!--span class='ico txt-h2 txt-bold border round-full bg-blue-light color-white'>M</span-->
      <img class="ico round-full" src="https://static.wixstatic.com/media/e10a80_5932a1ba843b45719a5607465c228af0~mv2.png">
      <div class="flex-parent flex-parent--column ml12">
        <span class="txt-bold txt-l color-blue">mostransport.info</span>
        <span class="txt-s">Анализ маршрутной сети городов</span>
      </div>
    </div>

    <form id='params' class="fixed w360" style="top:80px;">
      <h4 class='txt-m txt-bold mt30 mb12'>Выберите способ перемещения:</h4>
      <div class='select-container bg-blue color-white round-full border--0'>
        <select name='profile' class='select select--border-white round-full' style="box-shadow: none;padding: 6px 40px 6px 30px;">
          <option value='public_transport'>Общественный транспорт</option>
          <option value='driving'>Автомобиль</option>
          <option value='cycling'>Велосипед</option>
          <option value='walking'>Пешком</option>
        </select>
        <div class='select-arrow'></div>
      </div>

      <h4 class='txt-m txt-bold mt24 mb12'>Выберите время:</h4>

      <div class='mb24 align-center flex-parent flex-parent--row'>
        <button name='duration' class='btn btn--green mr12' data-value='10'>10 мин</button>
        <button name='duration' class='btn btn--yellow mr12' data-value='20'>20 мин</button>
        <button name='duration' class='btn btn--orange mr12' data-value='30'>30 мин</button>
      </div>    

      <label class='checkbox-container'>
        <input name="use_intervals" type='checkbox' />
        <div class='checkbox mr6'>
          <svg class='icon'><use xlink:href='#icon-check' /></svg>
        </div>
        Учитывать интервалы движения
      </label>

    </form> 

    <div id="info-box" class="mt24 pb12 none h-full scroll-styled scrolled">
      <h4 class='txt-m txt-bold mb12'>Статистика изохрона:</h4>
      <table id="stop_stat" class="table border--0">
        <thead>
          <tr>
            <th></th>
            <th>10 мин</th>
            <th>20 мин</th>
            <th>30 мин</th>
          </tr>
        </thead>
        <tbody>
          <tr class="info area none">
            <td>Площадь (км2):</td>
            <td class="time time-10"></td>
            <td class="time time-20"></td>
            <td class="time time-30"></td>
          </tr>
          <tr class="info velo-share none">
            <td>Сравнение с вело:</td>
            <td class="time time-10"></td>
            <td class="time time-20"></td>
            <td class="time time-30"></td>
          </tr>
        </tbody>
      </table>

      <h4 class='txt-m txt-bold mb12 mt30'>Статистика маршрутов:</h4>
      <table id="routes_stat" class="table border--0">
        <thead>
          <tr>
            <th>Маршрут</th>
            <th>Интервал</th>
            <th>Длина</th>
            <th>Стоимость</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>   
  </div>
  <div class='flex-child flex-child--grow'>
    <div id='map' class="h-full w-full"></div>
  </div>
</div>

<div id="links" class="flex-parent flex-parent--center-main mt24">
  <a href="https://www.facebook.com/alexradchenko" target="_blank" data-content="https://www.facebook.com/alexradchenko" data-type="external" rel="noopener" id="comp-ka9lcxis0imagelink" class="lb1imageItemlink">
    <img id="comp-ka9lcxis0imageimageimage" alt="Facebook" data-type="image" itemprop="image" src="https://upload.wikimedia.org/wikipedia/commons/8/84/FaceB.png" style="width: 25px; height: 25px; object-fit: cover;">
  </a>

  <a href="https://twitter.com/alex_radch" target="_blank" data-content="https://twitter.com/alex_radch" data-type="external" rel="noopener" id="comp-ka9lcxis0imagelink" class="lb1imageItemlink">
    <img id="comp-ka9lcxis1imageimageimage" alt="Twitter" data-type="image" itemprop="image" src="https://upload.wikimedia.org/wikipedia/commons/c/ce/Twitter_Logo.png" style="width: 25px; height: 25px; object-fit: cover;">
  </a>
  <a href="https://www.youtube.com/user/alexradchenko" target="_blank" data-content="https://www.youtube.com/user/alexradchenko" data-type="external" rel="noopener" id="comp-ka9lcxis0imagelink" class="lb1imageItemlink">
    <img id="comp-ka9lcxis2imageimageimage" alt="YouTube" data-type="image" itemprop="image" src="https://upload.wikimedia.org/wikipedia/commons/4/4c/Youtube_new.svg" style="width: 25px; height: 25px; object-fit: cover;">
  </a>
  <a href="https://www.instagram.com/mosurbanist/" target="_blank" data-content="https://www.instagram.com/mosurbanist/" data-type="external" rel="noopener" id="comp-ka9lcxis0imagelink" class="lb1imageItemlink">
    <img id="comp-ka9lcxis3imageimageimage" alt="Instagram" data-type="image" itemprop="image" src="https://upload.wikimedia.org/wikipedia/commons/a/a5/Instagram_icon.png" style="width: 25px; height: 25px; object-fit: cover;">
  </a>
  <a href=" https://t.me/urban_blog" target="_blank" data-content=" https://t.me/urban_blog" data-type="external" rel="noopener" id="comp-ka9lcxis0imagelink" class="lb1imageItemlink">
    <img id="comp-ka9lcxis3imageimageimage2" alt="Telegram" data-type="image" itemprop="image" src="https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg" style="width: 25px; height: 25px; object-fit: cover;">
  </a>
  <div class="fb-share-button mr12" data-href="https://www.mostransport.info/" data-layout="button" data-size="large">
    <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.mostransport.info%2F&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">
      Share
    </a>
  </div>
  <a class="twitter-share-button" href="https://twitter.com/intent/tweet?text=Анализ маршрутной сети Москвы​&url=https://www.mostransport.info/" data-size="large">
    Share
  </a>
</div>

<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/gb_EN/sdk.js#xfbml=1&version=v7.0&appId=306681460273296&autoLogAppEvents=1"></script>

  <script type="text/javascript">

    // Устанавливаем глобальные параметры
    var dataMosKey = "1271a705c49502b00213730c28f54f23";
    var publicToken = 'pk.eyJ1Ijoibmt0YiIsImEiOiJjazhscjEwanEwZmYyM25xbzVreWMyYTU1In0.dcztuEUgjlhgaalrc_KLMw';
    var secretToken = 'sk.eyJ1Ijoibmt0YiIsImEiOiJjazhueGY1MXEwMng1M21tajY0b2psNXNmIn0.Milq6xTw737s40ULVDjFtQ';
    var userName = 'nktb';

    // Выходы метро
    var pointsTileset = "nktb.bev2q4f8" //tileset объекты выходы метро
    var pointsDataset = "ck8pok8s300912skst8ff3i49"; //dataset объекты выходы метро

    var isoTileset = "nktb.9wtyq20f"; //tileset изохроны выходы метро
    var isoDataset = "ck8pow8fh0yci2tupmamotyh6"; //dataset изохроны выходы метро

    var pointsSourceLayer = "bus_stops";
    var isoSourceLayer = "isohrones";

    var iso_layers = [
      /*{name: 'walking', url: 'nktb.3s2j8c2h'},
      {name: 'cycling', url: 'nktb.3ka2s10w'},
      {name: 'driving', url: 'nktb.14cjlo9r'},
      {name: 'public_transport', url: 'nktb.19y282q8'}*/
    ];

    var data_layers = [
      {name_quantity: 'Кол-во домов', name_population: 'Кол-во жителей', name: 'houses', url: 'nktb.314cfju0',icon:'house'},
      {name_quantity: 'Кол-во офисов', name_population: 'Кол-во работников', name: 'offices', url: 'nktb.48uv4euq',icon:'suitcase'},
      {name_quantity: 'Кол-во университетов', name_population: 'Кол-во студентов', name: 'universities', url: 'nktb.3m9uqakn',icon:'college'}
    ];

    var times = [30,20,10];

    // Добавялем ключ для Mapbox
    mapboxgl.accessToken = publicToken;

    // Инициализируем карту
    var map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v11',
      center: [37.618936,55.754388],
      zoom: 11.5
    });
     
    // create the marker
    var marker = new mapboxgl.Marker();

    var obj_popup = new mapboxgl.Popup();
    var point_popup = new mapboxgl.Popup();

    // Добавляем строки в таблицу со статистикой изохрона
    data_layers.forEach(function(layer){
      tr1 = '<tr class="info '+layer.name+' none"><td>'+layer.name_quantity+':</td><td class="time time-10"></td><td class="time time-20"></td><td class="time time-30"></td></tr>';
      tr2 = '<tr class="info '+layer.name+'-population none"><td>'+layer.name_population+':</td><td class="time time-10"></td><td class="time time-20"></td><td class="time time-30"></td></tr>'
      
      $('#stop_stat').find('tbody').append(tr1);
      $('#stop_stat').find('tbody').append(tr2);
    });

  </script>

  <script type="text/javascript">
    // Загрузка Tileset для отображения объектов на карте

    // Loading Points data layer when map is ready
    map.on('load', function() {

      // Загружаем слои с изохронами
      iso_layers.forEach(function(layer){

        map.addSource(layer.name, {
          'type': 'vector',
          url: "mapbox://"+layer.url
        });

       times.forEach(function(t,i){
          if (i > 0){
            beforeLayer = layer.name+"-"+times[i-1];
          } else{
            beforeLayer = "";
          }
          
          map.addLayer({
            'id': layer.name+"-"+t,
            'type': 'fill',
            'source': layer.name,
            'source-layer': layer.name+"-"+t,
            'filter': ["all",["==",["get","profile"],profile],["match",["get","contour"],minutes, true, false]],
            'layout': {
              'visibility': 'visible'
            },
            'paint': {
              'fill-color': ["case",
                              ["==",["get","contour"],10],'#63d125',
                              ["==",["get","contour"],20],'#efd700',
                              ["==",["get","contour"],30],'#ef8725',
                              '#efac00'
                            ],
              //["concat",'cycling-',["get","contour"]]
              'fill-opacity': 0.5
            }
          });
        });
      });
      

      // Слой для отображения индивидуальных изохронов
      map.addSource('pointIsochrones', {
       type: 'geojson',
       data: {
         'type': 'FeatureCollection',
         'features': []
       }
      });

      map.addLayer({
       'id': 'pointIsoLayer',
       'type': 'fill',
       // Use "iso" as the data source for this layer
       'source': 'pointIsochrones',
       'layout': {},
       'paint': {
          'fill-color': ["case",
                          ["==",["get","contour"],10],'#63d125',
                          ["==",["get","contour"],20],'#efd700',
                          ["==",["get","contour"],30],'#ef8725',
                          '#efac00'
                        ],
          //["concat",'cycling-',["get","contour"]]
          'fill-opacity': 0.5
        }
      });
      

      // Слой для отображения маршрутов на карте
      map.addSource('routes', {
        'type': 'geojson',
        'data': {
          'type': 'FeatureCollection',
          'features': []
        }
      });

      map.addLayer({
        'id': 'routes',
        'type': 'line',
        'source': 'routes',
        'paint': {
          'line-width': 4,
          'line-color': '#F7455D'
        }
      });

     // Загружаем слой с точками
      map.addSource("points", {
          "type": "vector",
          "url": "mapbox://"+pointsTileset,
          "tileSize": 512
        }
      );

      map.addLayer({
        'id': 'points',
        'type': 'circle',
        'source': 'points',
        'source-layer': pointsSourceLayer,
        //'filter': false,
        'paint': {
          'circle-radius': {
            'stops': [[9, 2], [22, 15]]
          },
          'circle-color': '#3976bc'
        }
      });

      // Загружаем слои с доп. данными
      data_layers.forEach(function(layer){
        map.addSource(layer.name, {
            "type": "vector",
            "url": "mapbox://"+layer.url,
            "tileSize": 512
          }
        );

        map.addLayer({
          'id': layer.name,
          'type': 'symbol',
          'source': layer.name,
          'source-layer': layer.name,
          'filter': false,
          'layout': {
            'icon-image': layer.icon+'-15',
            'icon-padding': 0,
            'icon-allow-overlap': true
          }
        });
      });

      // Change the cursor to a pointer when it enters a feature in the 'points' layer.
      data_layers.map(function(l){return l.name}).concat('points').forEach(function(l){
        map.on('mouseenter', l, function(e) {
          map.getCanvas().style.cursor = 'pointer';
          if(e.features[0].source == 'points'){
            addPointPopup(e);
          }
          else {
            addObjPopup(e);
          }
        });

        // Change it back to a pointer when it leaves.
        map.on('mouseleave', l, function() {
          map.getCanvas().style.cursor = '';
          obj_popup.remove();
          point_popup.remove();
        });
      });

      function addObjPopup(e){
        obj_popup.setLngLat(e.lngLat)
          .setHTML(
            "<p>"+e.features[0].properties.name+"</p>"
            +
            "<p>"+e.features[0].properties.address+"</p>"
             +
            "<p>Кол-во жителей: "+e.features[0].properties.population+"</p>"
            +
            "<p>id: "+e.features[0].properties.id+"</p>"
            )
          .addTo(map);
      }

      function addPointPopup(e){
        point_popup.setLngLat(e.lngLat)
          .setHTML(
            "<div class='loading loading--s none'></div>"
            +
            "<p>Остановка: "+e.features[0].properties.StationName+"</p>"
            +
            "<p>Маршруты: "+e.features[0].properties.RouteNumbers+"</p>"
            )
          .addTo(map);
      }

      map.on('click', function(event) {
        //console.log(event);
        selected_point = map.queryRenderedFeatures(event.point, { layers: ['points']})[0];

        // create the popup
        var popup = new mapboxgl.Popup({ offset: 40 }).setHTML(
          "<div class='loading loading--s none'></div>"
          +
          "<p>Остановка: "+selected_point.properties.StationName+"</p>"
          +
          "<p>Маршруты: "+selected_point.properties.RouteNumbers+"</p>"
        );
           
        if(selected_point != null){
          console.log("selected_point");
          console.log(selected_point);
           
          marker.setLngLat(selected_point.geometry.coordinates);
          marker.setPopup(popup);
          marker.addTo(map);

          marker.togglePopup();

        }

        filterMap();
      });
      

    });

  </script>

  <script type="text/javascript">
    // Построение изохрона для одной точки
    
    var selected_point;          
    var profile = 'public_transport';
    var minutes = [0,10,20,30];
    var routeStops = [];
    var use_intervals = 0;

    // Target the "params" form in the HTML
    var params = document.getElementById('params');

    // When a user changes the value of profile or duration by clicking a button, change the parameter's value and make the API query again
    params.addEventListener('change', function(e) {
      if (e.target.name === 'profile') {
        profile = e.target.value;
        filterMap();
      } else if (e.target.name === 'duration') {
        minutes = parseInt(e.target.value);
        filterMap();
      }

      if(profile == 'public_transport'){
        use_intervals = (e.target.checked) ? (1) : (0);
        filterMap();
      } else {
        use_intervals = null;
      }

      console.log(use_intervals);

    });

    $('button[name="duration"]').on('click',function(e){
      e.preventDefault();
      btn = e.target;
      val = $(btn).data("value");

      if(minutes.includes(val)){
        minutes = minutes.filter(function(el){return el != val});
        $(btn).addClass("btn--stroke");
      } else{
        minutes.push(val);
        $(btn).removeClass("btn--stroke");
      }
      
      filterMap();
    });

    // Функция фильтрации изохронов на карте
    function filterMap(){

      // Очищаем InfoBox
      hideInfoBox();

      if(selected_point != null){
        // Очищаем слои с маршрутом и с индивидуальными изохронами
        map.getSource('pointIsochrones').setData({'type': 'FeatureCollection','features': []});
        map.getSource('routes').setData({'type': 'FeatureCollection','features': []});

        if (profile == 'public_transport'){
          routesMessage();
        } else {
          pointIsoMessage();
        }
        
        map.setFilter('pointIsoLayer', null);

        iso_layers.forEach(function(layer){
          times.forEach(function(t){
            map.setFilter(layer.name+"-"+t, false);
          });
        });

      } /*else {
        map.setFilter('pointIsoLayer', false);

        filter_minutes = ["match",["get", "contour"], minutes, true, false];
        filter_profile = ["==",["get", "profile"], profile];
        iso_layers.forEach(function(layer){
          times.forEach(function(t){
            map.setFilter(layer.name+"-"+t, ["all",filter_profile, filter_minutes]);
          });
        });
      }*/
    }

    // Отправка сообщения на сервер WIX для получения изохронов по выбранной точке
    function pointIsoMessage(){
      //console.log(selected_point);
      params = {
        messageType: "POINT_ISO",
        id: [selected_point.properties.global_id],
        profile: profile,
        minutes: minutes,
        with_interval: use_intervals
      }
      window.parent.postMessage(params, "*");
      $('.loading').removeClass('none');
    }

    // Отправка сообщения на сервер WIX для получения координат маршрутов
    function routesMessage(){
      //console.log(selected_point);
      params = {
        messageType: "ROUTES",
        id: selected_point.properties.global_id,
        routes: selected_point.properties.RouteNumbers
      }
      window.parent.postMessage(params, "*");
      $('.loading').removeClass('none');
    }

    // Отправка сообщения на сервер WIX для получения изохронов для остановок маршрута
    function routePointsMessage(point_ids){
      //console.log(selected_point);
      params = {
        messageType: "ROUTE_POINTS_ISO",
        id: point_ids,
        profile: 'walking',
        minutes: [5]
      }
      window.parent.postMessage(params, "*");
      $('.loading').removeClass('none');
    }

    // Отправка сообщения на сервер WIX для получения изохронов для сравнения площади
    function isoCompareMessage(profile){
      params = {
        messageType: "ISO_COMPARE",
        id: [selected_point.properties.global_id],
        profile: profile,
        minutes: minutes
      }
      window.parent.postMessage(params, "*");
      $('.loading').removeClass('none');
    }

    // Обработчик события получения сообщения с сервера WiX
    window.onmessage = function(e){
      $('.loading').addClass('none');

      console.log("Result:");
      console.log(e.data);

      if(e.data.messageType == "POINT_ISO") {
        isoFeatures = getPolygonFeatures(e.data.isochrones);
        console.log(isoFeatures);
        map.getSource('pointIsochrones').setData(isoFeatures);
        featureWithInfo = addFeatureInfo(isoFeatures);
        displayInfo(featureWithInfo);
        filter_objects(featureWithInfo);
      } 
      else if(e.data.messageType == "ROUTES"){
        routeFeatures = getRouteFeatures(e.data.routes);
        map.getSource('routes').setData(routeFeatures);
        displayRouteStat(routeFeatures);

        last_min = minutes.sort(function(a, b){return b - a})[0];
        routes = getRouteStops(routeFeatures);
        route = routes.find(function(r){return r.contour == last_min});

        console.log("Stops:");
        console.log(route);
        //routePointsMessage(route.id);
        pointIsoMessage();
      }
      else if(e.data.messageType == "ROUTE_POINTS_ISO"){
        stopFeatures = getRouteStopsFeatures(e.data.isochrones);
        map.getSource('pointIsochrones').setData(stopFeatures);
        displayInfo(stopFeatures);
        filter_objects(stopFeatures);
        isoCompareMessage("cycling");
      }
      else if(e.data.messageType == "ISO_COMPARE"){
        e.data.isochrones.forEach(function(iso){
          polygon = turf.polygon([iso.polygon]);
          area_1 = Number($('.info.area').find('.time-'+iso.contour).html());
          area_2 = getFeatureArea(polygon);
          share = (area_1/area_2*100).toFixed(2);
          $('.info.velo-share').find('.time-'+iso.contour).html(area_2+" ("+share+"%)");
          $('.info.velo-share').removeClass('none');
        });
      }
    }

    function getRouteStops(routesCollection){

      point = selected_point;
      var stopPoint = turf.point(point.geometry.coordinates);
      routeStops = [];
      
      minutes = minutes.filter(function(m){return m > 0}).sort(function(a, b){return b-a});

      var stops = [];

      routesCollection.features.forEach(function(route){

        var stopsOnRoute = [];

        // Определяем номер маршрута
        var route_num = route.routeNumber;

        if(route.typeOfTransport == "автобус"){
            route_num = "А"+route_num;
        } else if(route.typeOfTransport == "троллейбус"){
            route_num = "Тб"+route_num;
        } else if(route.typeOfTransport == "трамвай"){
            route_num = "Тм"+route_num;
        } 

        // Отбираем из остановок те, которые входят в изохрон маршрута для заданного времени
        route.geometry.coordinates.forEach(function(direction, dirIndex){
          
          // Из маршрута берём названия остановок
          if (dirIndex == 0){
            track = route.trackOfFollowing.replace(/«|»/g, "");
          } else if (dirIndex == 1){
            track = route.reverseTrackOfFollowing.replace(/«|»/g, "");
          }

          if(track.includes(point.properties.StationName)){
            // Строим линию направления
            line = turf.lineString(direction);

            // Определяем близжайшую к остановке точку на маршруте
            pointOnRoute = turf.nearestPointOnLine(line, stopPoint);

            // Находим точки остановок для маршрута
            stopsOnRoute = map.querySourceFeatures('points', {sourceLayer: 'bus_stops', filter: 
              ["all",
                ["in",["get","StationName"],track],
                ["in",route_num,["get","RouteNumbers"]]
              ]});

            // Определяем близжайшую точку на маршруте для всех остановок направления
            stopsOnRoute.forEach(function(s){
              p = turf.point(s.geometry.coordinates);
              s.pointOnRoute = turf.nearestPointOnLine(line, p);
            });

            // Определяем последнюю точку на направлении
            stp = direction[0];
            enp = direction[direction.length-1];

            if(stp[0] == enp[0] && stp[1] == enp[1]){
              lastPoint = turf.point(direction[direction.length-2]);
            } else {
              lastPoint = turf.point(direction[direction.length-1]);
            }
            
            // Обрезаем линию от остановки до конца маршрута
            line = turf.lineSlice(pointOnRoute, lastPoint, line);

            minutes.forEach(function(t){
              // Обрезаем линию от остановки до расстояния, которое можно проехать за заданное время
              start = 0;
              stop = 15 * t/60;
              sliced = turf.lineSliceAlong(line, start, stop, {units: 'kilometers'});
              sliced_buffer = turf.buffer(sliced, 0.02, {units: 'kilometers'});

              // Определяем точки, которые находятся внутри маршрута заданной длины
              stops = stopsOnRoute.filter(function(s){
                return turf.booleanPointInPolygon(s.pointOnRoute, sliced_buffer);
              });

              ids = stops.map(function(r){return r.properties.global_id});

              contour = routeStops.find(function(r){return r.contour == t});

              if (contour){
                contour.id = [...new Set(contour.id.concat(ids))];
              } else {
                routeStops.push({contour: t, id: [...new Set(ids)]});
              }
              
            });
          }
        });
      });

      return routeStops;
    }


    function getPolygonFeatures(isochrones){

      isochrones = isochrones.sort(function(a, b){return b.contour - a.contour});

      data = {
         'type': 'FeatureCollection',
         'features': []
      };

      isochrones.forEach(function(p){
        geo_type = "";
        polygon = [];

        if(p.profile == "public_transport"){
          polygon = p.polygon;
          if(p.polygon.length == 1){
            geo_type = "Polygon";
          } else{
            geo_type = "MultiPolygon";
          }

        } else {
          polygon = [p.polygon];
          geo_type = "Polygon";
        }

        feature = {
          "type": "Feature",
          "properties": {
            "id": p.id,
            "profile": p.profile, 
            "global_id": p.global_id, 
            "contour": p.contour
          },
          "geometry": {
            "type": geo_type,
            "coordinates": polygon
          }
        };

        data.features.push(feature);
      });
      return data;
    }

    var geodata;

    function getRouteFeatures(routesArray){
      data = {
         'type': 'FeatureCollection',
         'features': []
      };

      routesArray.forEach(function(route){
        geometry = JSON.parse(route.geoData.replace(/'/g, '"'));

        feature = {
          'type': 'Feature',
          'trackOfFollowing': route.trackOfFollowing,
          'reverseTrackOfFollowing': route.reverseTrackOfFollowing,
          'routeNumber': route.routeNumber,
          'typeOfTransport': route.typeOfTransport,
          'route_code': route.route_code,
          'route_cost': route.route_cost,
          'route_length': route.route_length,
          'interval': route.avg_fact_interval
        };

        feature.geometry = geometry;

        data.features.push(feature);
      });

      return data;
    }

    function getRouteStopsFeatures(stops){
      data = {
         'type': 'FeatureCollection',
         'features': []
      };

      routeStops.forEach(function(r){
        stops = stops.filter(function(s){return r.id.includes(s.global_id);});
        var feature = turf.polygon([stops[0].polygon]);

        for (i = 1; i < stops.length; i++) {
          feature = turf.union(feature, turf.polygon([stops[i].polygon]));
        }

        feature.properties = {
            "id": selected_point.properties.global_id+"-"+"public_transport-"+r.contour,
            "profile": "public_transport", 
            "global_id": selected_point.properties.global_id, 
            "contour": r.contour
          }

        data.features.push(feature);
      });

      data = addFeatureInfo(data);
      console.log(data);
      return data;
    }

    // Функция добавления доп. информации к изохронам
    function addFeatureInfo(featureCollection){
      featureCollection.features.forEach(function(feature){
        feature.properties.area =  getFeatureArea(feature);
        feature.properties.area_unit = "км";
      });

      data_layers.forEach(function(layer){
        featureCollection = getInfoFromObjectsInside(featureCollection, layer.name);
        //feature.properties[layer.name] = data.quantity;
        //feature.properties[layer.name + "-population"] = data.population;
      });

      return featureCollection;
    } 

    // Функция расчёта площади изохрона
    function getFeatureArea(feature){
      var area = 0;

      polygon = feature.geometry.coordinates;

      if (feature.geometry.type == "Polygon"){
        p = turf.polygon(polygon);
        area += turf.area(p);
      } else if (feature.geometry.type == "MultiPolygon"){
        p = turf.multiPolygon(polygon);
        area += turf.area(p);
      }

      return (area/1000000).toFixed(2);
    }

    // Функция расчёта кол-ва объектов и кол-ва людей внутри изохрона
    function getInfoFromObjectsInside(featureCollection, source_name){
      console.log("getInfoFromObjectsInside");
      console.log(source_name);

      minutes_sorted = minutes.sort(function(a, b){return b - a});
      filtered_arr = [];

      minutes_sorted.forEach(function(m,i){
        feature = featureCollection.features.find(function(f){return f.properties.contour == m});
        filtered = []

        if(i == 0){
          filtered = getObjectsInside(feature, source_name);
        } else {
          filtered = turf.pointsWithinPolygon(filtered_arr[i-1], feature);
        }

        filtered_arr.push(filtered);
        //console.log(filtered);

        quantity = filtered.features.length;

        if(quantity > 0){
          populations = filtered.features.map(function(f){return f.properties.population});
          //console.log(populations);

          population = populations.reduce(function(total, p){return total + p});

          data = {quantity: quantity, population: population};
        } else {
          data = {quantity: 0, population: 0};
        }

        feature.properties[source_name] = data.quantity;
        feature.properties[source_name + "-population"] = data.population;
      });

      return featureCollection;
    }

    // Функция расчёта кол-ва объектов и кол-ва людей внутри изохрона
    function getObjectsInside(feature, source_name){
      console.log("getObjectsInside");

      points = map.querySourceFeatures(source_name, { sourceLayer: source_name});
      
      points = turf.featureCollection(points);
      filtered = turf.pointsWithinPolygon(points, feature);

      // Убираем дубликаты точек
      filtered_points = [];
      filtered.features.forEach(function(p){
        ids = filtered_points.map(function(m){return m.properties.id});
        if (filtered_points.length == 0 || ids.includes(p.properties.id) == false){
          filtered_points.push(p);
        }
      });

      return turf.featureCollection(filtered_points);
    }

    // Функция отображения доп. информации об изохроне
    function displayInfo(featureCollection){
      featureCollection.features.forEach(function(feature){
        p = feature.properties;
        $('.info.area').find('.time-'+p.contour).html(p.area);
        $('.info.area').removeClass('none');

        data_layers.forEach(function(layer){
          $('.info.'+layer.name).find('.time-'+p.contour).html(p[layer.name]);
          $('.info.'+layer.name).removeClass('none');

          if(p[layer.name+'-population'] > 0){
            $('.info.'+layer.name+'-population').find('.time-'+p.contour).html(p[layer.name+'-population']);
            $('.info.'+layer.name+'-population').removeClass('none');
          }
        });
      });
      $('#info-box').removeClass('none');
    }

    // Функция отображения статистики по маршруту
    function displayRouteStat(featureCollection){

      $('#routes_stat tbody').html("");

      featureCollection.features.forEach(function(feature){
        f = new Intl.NumberFormat('ru-RU', {style: 'decimal'});
        row = document.createElement("tr");
        $(row).append('<td>'+feature.route_code+'</td>');
        $(row).append('<td>'+feature.interval+' мин</td>');
        $(row).append('<td>'+feature.route_length+' км</td>');
        $(row).append('<td>'+f.format(feature.route_cost)+' руб</td>');

        $('#routes_stat tbody').append(row);
      });
    }

    // Функция очистки информации
    function hideInfoBox(){
      $('#info-box').addClass('none');  
      $('#info-box').find('info').addClass('none');
      $('.info').find('.time').html("");
    }

    // Функция фильтрации объектов, которые попали в изохрон
    function filter_objects(featureCollection){
      last_min = minutes.sort(function(a, b){return b - a})[0];
      feature = featureCollection.features.find(function(f){return f.properties.contour == last_min});

      data_layers.forEach(function(l){
        filtered = getObjectsInside(feature, l.name);
        filtered_ids = filtered.features.map(function(f){return f.properties.id});
        if(filtered_ids.length > 0){
          map.setFilter(l.name,["match",["get","id"],filtered_ids,true,false])
        }
      });
    }

  </script>

</body>
</html>